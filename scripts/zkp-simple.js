import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import dotenv from 'dotenv';
import {
  Field,
  Poseidon,
  Struct,
  CircuitString,
  ZkProgram,
  Provable,
  Bool
} from 'o1js';

// Obtenir le r√©pertoire actuel
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Charger les variables d'environnement
dotenv.config();

/**
 * Simulation d'extraction OCR pour attestation d'h√©bergement
 * Retourne un objet avec les donn√©es extraites
 */
function simulateOCR() {
  console.log("üîç Simulation de l'extraction OCR d'une attestation d'h√©bergement...");

  // Donn√©es simul√©es d'une attestation d'h√©bergement
  return {
    host: {
      firstName: "Jean",
      lastName: "Dupont",
      address: "123 Rue de la R√©publique, 75001 Paris, France",
      dob: "15/05/1970"
    },
    guest: {
      firstName: "Marie",
      lastName: "Lambert",
      dob: "23/08/1992"
    },
    documentType: "Attestation d'h√©bergement",
    documentDate: "10/01/2025",
    validUntil: "10/01/2026",
    containsSignature: true,
    signatureDate: "10/01/2025",
    officialStamp: true,
    textContent:
      `ATTESTATION D'H√âBERGEMENT

      Je soussign√©, Jean Dupont, n√© le 15/05/1970 √† Lyon,
      Demeurant au 123 Rue de la R√©publique, 75001 Paris, France,

      Atteste sur l'honneur h√©berger √† mon domicile :
      Marie Lambert, n√©e le 23/08/1992 √† Marseille,

      Cette attestation est √©tablie pour servir et valoir ce que de droit.

      Fait √† Paris, le 10/01/2025

      Signature: [Signature manuscrite]
      [Tampon officiel]`
  };
}

/**
 * Classe repr√©sentant une personne pour le ZKP
 */
class Person extends Struct({
  firstNameHash: Field,  // Hash du pr√©nom
  lastNameHash: Field,   // Hash du nom
  ageProof: Field,       // Preuve de l'√¢ge (en jours) sans r√©v√©ler la date exacte
  addressHash: Field     // Hash de l'adresse
}) {
  // Cr√©e une instance √† partir de donn√©es textuelles
  static fromPersonData(person, address = '', referenceDate = new Date()) {
    // Hachage des donn√©es sensibles
    const firstNameHash = Poseidon.hash(CircuitString.fromString(person.firstName).toFields());
    const lastNameHash = Poseidon.hash(CircuitString.fromString(person.lastName).toFields());
    const addressHash = address ?
      Poseidon.hash(CircuitString.fromString(address).toFields()) :
      Field(0);

    // Calcul de l'√¢ge en jours (sans r√©v√©ler la date de naissance)
    const dobParts = person.dob.split('/');
    const birthDate = new Date(
      parseInt(dobParts[2]),
      parseInt(dobParts[1]) - 1,
      parseInt(dobParts[0])
    );
    const ageInDays = Math.floor(
      (referenceDate.getTime() - birthDate.getTime()) / (1000 * 60 * 60 * 24)
    );

    return new Person({
      firstNameHash: firstNameHash,
      lastNameHash: lastNameHash,
      ageProof: Field(ageInDays),
      addressHash: addressHash
    });
  }
}

/**
 * Classe repr√©sentant un document/attestation pour le ZKP
 */
class Document extends Struct({
  hostData: Person,
  guestData: Person,
  documentHash: Field,
  isSignedAndStamped: Field,
  validityDays: Field
}) {
  // Cr√©e une instance √† partir des donn√©es d'une attestation
  static fromAttestation(attestation) {
    const referenceDate = new Date();

    // Cr√©ation des objets Person pour l'h√¥te et l'invit√©
    const hostPerson = Person.fromPersonData(
      attestation.host,
      attestation.host.address || '',
      referenceDate
    );

    const guestPerson = Person.fromPersonData(
      attestation.guest,
      '',
      referenceDate
    );

    // Hachage du contenu du document pour r√©f√©rence
    // Limiter la taille du texte (CircuitString a une limite)
    const documentTextShort = attestation.textContent.substring(0, 30); // Limite √† 30 caract√®res
    const documentHash = Poseidon.hash([
      Field(documentTextShort.length),
      ...Array.from(documentTextShort).map(c => Field(c.charCodeAt(0)))
    ]);

    // Calcul de la dur√©e de validit√© en jours
    const dateParts = attestation.validUntil.split('/');
    const validUntil = new Date(
      parseInt(dateParts[2]),
      parseInt(dateParts[1]) - 1,
      parseInt(dateParts[0])
    );
    const validityDays = Math.floor(
      (validUntil.getTime() - referenceDate.getTime()) / (1000 * 60 * 60 * 24)
    );

    return new Document({
      hostData: hostPerson,
      guestData: guestPerson,
      documentHash: documentHash,
      isSignedAndStamped: Field(attestation.containsSignature && attestation.officialStamp ? 1 : 0),
      validityDays: Field(validityDays > 0 ? validityDays : 0)
    });
  }
}

/**
 * Programme ZK pour v√©rifier l'attestation d'h√©bergement
 */
const AttestationVerifier = ZkProgram({
  name: "attestation-verifier",
  publicOutput: Field,

  methods: {
    // V√©rification de validit√© du document
    verifyDocumentValidity: {
      privateInputs: [Document],

      method(document) {
        // V√©rification 1: Document valide (sign√©, tamponn√© et non expir√©)
        const isValidDoc = document.isSignedAndStamped.equals(Field(1)).and(
          document.validityDays.greaterThan(Field(0))
        );

        // V√©rification que le document est effectivement valide
        isValidDoc.assertTrue("Le document doit √™tre valide, sign√© et non expir√©");

        // Retourner un hachage du document pour r√©f√©rence
        return Poseidon.hash([
          document.documentHash,
          document.isSignedAndStamped,
          document.validityDays
        ]);
      }
    },

    // V√©rification que l'h√¥te est majeur
    verifyHostIsAdult: {
      privateInputs: [Person],

      method(host) {
        // V√©rification 2: H√¥te majeur (plus de 18 ans)
        const isAdult = host.ageProof.greaterThanOrEqual(Field(6570)); // 18 ans * 365 jours

        // V√©rification que l'h√¥te est majeur
        isAdult.assertTrue("L'h√¥te doit √™tre majeur");

        // Retourner un hachage de l'h√¥te pour r√©f√©rence
        return Poseidon.hash([
          host.firstNameHash,
          host.lastNameHash,
          host.ageProof
        ]);
      }
    },

    // V√©rification que l'adresse est en France
    verifyAddressInFrance: {
      privateInputs: [Person],

      method(person) {
        // V√©rification 3: Adresse en France
        // Simplification - v√©rifier simplement que le hash n'est pas z√©ro
        const isNonZero = person.addressHash.equals(Field(0)).not();

        // V√©rification que l'adresse existe
        isNonZero.assertTrue("L'adresse doit √™tre sp√©cifi√©e");

        // Retourner un hash simple pour la preuve
        return Field(1); // Valeur constante pour la preuve
      }
    },

    // V√©rification de l'identit√© de l'invit√©
    verifyGuestIdentity: {
      privateInputs: [Person],

      method(guest) {
        // Simplification - v√©rifier simplement que le nom est non vide
        const hasName = guest.firstNameHash.equals(Field(0)).not();
        hasName.assertTrue("L'invit√© doit avoir un nom");

        // Retourner un hash simple pour la preuve
        return Field(1);
      }
    }
  }
});

/**
 * Fonction principale qui ex√©cute le processus ZKP
 */
async function main() {
  try {
    console.log("üöÄ D√©marrage du processus de v√©rification ZKP avec Mina o1js...");

    // Simulation OCR
    const extractedData = simulateOCR();
    console.log("‚úÖ Extraction OCR simul√©e avec succ√®s");
    console.log("üìù Donn√©es extraites:", JSON.stringify(extractedData, null, 2));

    // Pr√©paration du document pour le ZKP
    console.log("\nüîê Pr√©paration des donn√©es pour le Zero Knowledge Proof...");
    const documentZKP = Document.fromAttestation(extractedData);
    console.log("üìä Document ZKP pr√©par√©");

    // Compilation du circuit (n√©cessaire pour o1js)
    console.log("\nüî® Compilation du circuit ZKP...");
    console.log("‚ö†Ô∏è  Cette √©tape peut prendre plusieurs minutes la premi√®re fois");
    await AttestationVerifier.compile();
    console.log("‚úÖ Circuit compil√© avec succ√®s");

    // G√©n√©ration des preuves ZKP
    console.log("\nüîç G√©n√©ration des preuves ZKP...");

    // 1. Preuve de validit√© du document
    console.log("1Ô∏è‚É£ G√©n√©ration de la preuve de validit√© du document...");
    const documentValidityProof = await AttestationVerifier.verifyDocumentValidity(documentZKP);
    const documentValidityHash = documentValidityProof.publicOutput.toString();
    console.log("‚úÖ Preuve g√©n√©r√©e, hash:", documentValidityHash);

    // 2. Preuve que l'h√¥te est majeur
    console.log("2Ô∏è‚É£ G√©n√©ration de la preuve de majorit√© de l'h√¥te...");
    const hostAdultProof = await AttestationVerifier.verifyHostIsAdult(documentZKP.hostData);
    const hostAdultHash = hostAdultProof.publicOutput.toString();
    console.log("‚úÖ Preuve g√©n√©r√©e, hash:", hostAdultHash);

    // 3. Preuve que l'adresse est en France
    console.log("3Ô∏è‚É£ G√©n√©ration de la preuve de validit√© de l'adresse...");
    const addressProof = await AttestationVerifier.verifyAddressInFrance(documentZKP.hostData);
    const addressHash = addressProof.publicOutput.toString();
    console.log("‚úÖ Preuve g√©n√©r√©e, hash:", addressHash);

    // 4. Preuve que l'invit√© est correctement identifi√©
    console.log("4Ô∏è‚É£ G√©n√©ration de la preuve d'identit√© de l'invit√©...");
    const guestIdentityProof = await AttestationVerifier.verifyGuestIdentity(documentZKP.guestData);
    const guestIdentityHash = guestIdentityProof.publicOutput.toString();
    console.log("‚úÖ Preuve g√©n√©r√©e, hash:", guestIdentityHash);

    // G√©n√©ration d'identifiants de transaction fictifs
    const transactionIds = {
      documentValidityTxId: `MinaTx_${documentValidityHash.substring(0, 10)}`,
      hostAdultTxId: `MinaTx_${hostAdultHash.substring(0, 10)}`,
      addressTxId: `MinaTx_${addressHash.substring(0, 10)}`,
      guestIdentityTxId: `MinaTx_${guestIdentityHash.substring(0, 10)}`
    };

    // Cr√©ation du certificat final
    const certificate = {
      title: "CERTIFICAT DE V√âRIFICATION - ATTESTATION D'H√âBERGEMENT",
      date: new Date().toLocaleDateString('fr-FR'),
      originalDocument: {
        type: extractedData.documentType,
        date: extractedData.documentDate,
        validUntil: extractedData.validUntil
      },
      host: {
        nameInitials: `${extractedData.host.firstName.charAt(0)}.${extractedData.host.lastName.charAt(0)}.`,
        addressHash: documentZKP.hostData.addressHash.toString()
      },
      guest: {
        nameInitials: `${extractedData.guest.firstName.charAt(0)}.${extractedData.guest.lastName.charAt(0)}.`,
      },
      validatedAffirmations: [
        {
          statement: "L'attestation d'h√©bergement est valide, sign√©e et tamponn√©e",
          confidence: "100%",
          zkProofHash: documentValidityHash
        },
        {
          statement: "L'h√©bergeur est majeur",
          confidence: "100%",
          zkProofHash: hostAdultHash
        },
        {
          statement: "L'adresse de l'h√©bergeur est valide",
          confidence: "100%",
          zkProofHash: addressHash
        },
        {
          statement: "L'h√©berg√© est correctement identifi√©",
          confidence: "100%",
          zkProofHash: guestIdentityHash
        }
      ],
      blockchainTransactions: transactionIds,
      verificationMethod: "Mina Protocol Zero Knowledge Proof (o1js)",
      verificationDate: new Date().toISOString(),
      legalValidity: "Ce certificat prouve cryptographiquement la validit√© des affirmations sans r√©v√©ler les donn√©es personnelles"
    };

    // Affichage du certificat final
    console.log("\nüìã CERTIFICAT G√âN√âR√â AVEC SUCC√àS :");
    console.log(JSON.stringify(certificate, null, 2));

    // Sauvegarde du certificat dans un fichier
    const outputPath = path.resolve(process.cwd(), 'certificate.json');
    fs.writeFileSync(outputPath, JSON.stringify(certificate, null, 2));
    console.log(`\nüìÑ Certificat sauvegard√© dans ${outputPath}`);

    console.log("\n‚ú® PROCESSUS TERMIN√â AVEC SUCC√àS ‚ú®");

  } catch (error) {
    console.error("‚ùå Erreur lors du processus:", error);

    if (error.message && error.message.includes("compile")) {
      console.error("\n‚ö†Ô∏è Erreur de compilation du circuit ZKP. Assurez-vous d'avoir suffisamment de m√©moire disponible.");
      console.error("üí° Conseil: Essayez d'augmenter la m√©moire disponible pour Node.js avec:");
      console.error("   NODE_OPTIONS=--max-old-space-size=8192 node scripts/zkp-simple.js");
    }
  }
}

// Ex√©cuter la fonction principale
main().catch(error => {
  console.error("‚ùå Erreur non g√©r√©e:", error);
});